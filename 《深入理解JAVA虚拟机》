
JAVA虚拟机的作用
    提供一个Java代码运行的托管环境，忽略底层硬件的实现，一处编写到处运行。这个托管环境包括了内存的自动管理以及垃圾回收，并且还可以统一处理各类异常，如：数组越界，内存溢出等，避免在写业务代码时，还需要关心底层的实现。

JVM怎样执行一个java文件
    首先，java文件需要被编译成java class文件，class文件是由一个个字节码组成，所以也被称为java字节码，加载到虚拟机中时，被放入到方法区中，每执行到一个java方法就会对应在java方法栈中的塞入一个新的栈帧，用于存放局部变量以及字节码的操作数。PC寄存器用于保存java字节码的行号指示器。当执行完当前方法或者被异常中断结束时，这个栈帧就会被弹出去。


JVM执行class文件的方式
    主要有两种执行方式，一种是针对class文件的一行行字节码，逐行翻译成底层硬件能够理解并且执行的机器码。边翻译边执行，这种方式叫解释执行。这种方式前期解释时间短。可以立马上手执行。（java代码文件   [编译]->    java class字节码文件   [编译或翻译]->   机器码文件）

    另外一种是提前以java方法为单位将字节码翻译成机器码，然后再执行，这种方式叫做即时执行，JIT  just in time compilation。这种方式前期解释时间长，但后面执行时速度更快。

   HotSpot兼容了两种执行方式，采用混合模式，普通代码用解释执行，而反复、经常执行的热点代码用即时执行。

提问：为什么不全用JIT即时编译执行？

    有些类 ，如类初始化器，只会执行一遍，这种情况确实不适合使用即时编译编译成机器码再执行，直接解释执行效率更高，一次过。

    解释执行不需要生成机器码文件，边翻译就可以边执行，而即时执行，因为要提前翻译成机器码文件，而且机器码文件会比class字节码文件要大，容易增加代码存储空间，而且机器码文件是保存在内存中的。

   即时编译很重视代码的编译优化，但这个优化需要借助程序运行时采集足够多的信息才能明确优化点，所以，借助前期的解释执行，采集程序运行时的信息，再即时编译执行。像这种动态编译它的最终执行效率有可能超过C++的静态编译。

HotSpot集成了三个   即时   编译器，采用分层编译
    Java7 以后 包含了 C1 client编译器、C2  server编译器。client编译器设计是用来提供给客户端使用的，因为需要频繁启动，要求是编译时间短，启动快，编译优化力度小。server编译器设计是用来给服务器端使用的，服务时间长并且稳定，要求运行的性能好，效率高。所以编译优化的力度要高，执行起来更快。目前的分层编译的措施就是刚开始热点代码用C1编译，然后热点的热点，再用C2编译。

    Java10 以后包含了Graal编译器。

JAVA里面除了对象以外的八大基本类型（基本类型 + 引用类型 = JAVA所有类型）
   分别为：数值 -> short   int    float    double   long      字符->  char    byte      真假-> boolean

   除了这八个基本类型以外，其他的数据或者字符类型都是以对象的形式存在的，也就是都被定义成为一个类，jvm在编译期间看到是基本类型，就提前分配好预定大小的空间，而如果是类对象，就需要划分一个内存块，并用指针指向进行引用。

   譬如String，在java里面其实只是一个类，类里面维护了一个final char[] 字符数据，一旦申明，那么这个字符串引用的地址就不能再变更，但是可以往里面赋随意的字符串值。

   而在JVM里面其实是把boolean当做int型数据来处理的。

   譬如 boolean flag = true ;  此时 flag = iconst_1 = true ; 如果 将 flag 改成等于 iconst_2，那么此时  if( flag ) 依然成立，因为if()条件里面值只要大于0就为true，但是 if( flag == true ) 则不再成立。flag不为iconst_1，则不等于true。

JVM加载JAVA类的流程












































